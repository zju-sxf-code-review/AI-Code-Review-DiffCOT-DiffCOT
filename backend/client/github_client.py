"""GitHub API client for fetching repository and PR information.

Supports both Web application usage and GitHub Actions CI/CD environment.
"""

import os
import re
import base64
import time
from typing import Dict, Any, List, Optional, Tuple

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from configs.constants import GITHUB_API_BASE_URL, GITHUB_API_VERSION
from utils.logger import get_logger

logger = get_logger(__name__)


class GitHubAPIError(Exception):
    """Raised when GitHub API calls fail."""
    pass


class GitHubClient:
    """Client for interacting with GitHub API to fetch repository and PR data.

    Supports both Web application and GitHub Actions environments with
    optional file filtering for generated files and excluded directories.
    """

    # Patterns to identify generated files
    GENERATED_FILE_MARKERS = [
        '@generated by',
        '@generated',
        'Code generated by OpenAPI Generator',
        'Code generated by protoc-gen-go',
        'DO NOT EDIT',
        'AUTO-GENERATED',
    ]

    def __init__(
        self,
        token: Optional[str] = None,
        excluded_dirs: Optional[List[str]] = None,
        filter_generated: bool = False
    ):
        """Initialize GitHub client.

        Args:
            token: GitHub personal access token or OAuth token.
                   If None, reads from GITHUB_TOKEN env var.
            excluded_dirs: List of directories to exclude from PR diffs.
                          Can also be set via EXCLUDE_DIRECTORIES env var (comma-separated).
            filter_generated: Whether to filter out generated files from diffs.
        """
        self.token = token or os.environ.get('GITHUB_TOKEN')
        if not self.token:
            raise ValueError(
                "No GitHub token found. Please set GITHUB_TOKEN environment variable "
                "or provide token parameter."
            )

        self.headers = {
            'Authorization': f'Bearer {self.token}',
            'Accept': 'application/vnd.github.v3+json',
            'X-GitHub-Api-Version': GITHUB_API_VERSION
        }
        self.base_url = GITHUB_API_BASE_URL
        self.filter_generated = filter_generated

        # Setup session with retry strategy for network resilience
        self.session = requests.Session()
        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "POST", "PUT", "DELETE", "OPTIONS", "TRACE"],
            raise_on_status=False
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("https://", adapter)
        self.session.mount("http://", adapter)
        self.session.headers.update(self.headers)

        # Setup excluded directories
        if excluded_dirs is not None:
            self.excluded_dirs = excluded_dirs
        else:
            # Read from environment variable if available
            exclude_env = os.environ.get('EXCLUDE_DIRECTORIES', '')
            self.excluded_dirs = [d.strip() for d in exclude_env.split(',') if d.strip()]

        if self.excluded_dirs:
            logger.info(f"Excluded directories: {self.excluded_dirs}")

        logger.info("GitHub API client initialized successfully")

    def validate_token(self) -> Tuple[bool, str]:
        """Validate that the token has access to GitHub API.

        Returns:
            Tuple of (success, error_message)
        """
        try:
            response = self.session.get(
                f"{self.base_url}/user",
                timeout=10
            )
            if response.status_code == 200:
                user = response.json()
                logger.info(f"GitHub token validated for user: {user.get('login')}")
                return True, ""
            else:
                return False, f"Token validation failed: {response.status_code}"
        except Exception as e:
            return False, f"Token validation error: {str(e)}"

    def parse_repo_url(self, url: str) -> Tuple[Optional[str], Optional[str]]:
        """Parse GitHub repository URL to extract owner and repo name.

        Args:
            url: GitHub repository URL

        Returns:
            Tuple of (owner, repo_name) or (None, None) if invalid
        """
        # Clean up URL first - remove trailing slashes and .git suffix
        url = url.strip().rstrip('/')
        if url.endswith('.git'):
            url = url[:-4]

        patterns = [
            # Match: github.com/owner/repo or github.com:owner/repo
            r'github\.com[:/]([^/]+)/([^/]+)$',
        ]

        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                owner = match.group(1)
                repo = match.group(2)
                logger.info(f"Parsed URL '{url}' -> owner='{owner}', repo='{repo}'")
                return owner, repo

        logger.warning(f"Failed to parse GitHub URL: {url}")
        return None, None

    def _is_excluded(self, filepath: str) -> bool:
        """Check if a file should be excluded based on directory patterns.

        Args:
            filepath: File path to check

        Returns:
            True if file should be excluded
        """
        for excluded_dir in self.excluded_dirs:
            # Normalize excluded directory (remove leading ./ if present)
            normalized = excluded_dir[2:] if excluded_dir.startswith('./') else excluded_dir

            # Check if file starts with excluded directory
            if filepath.startswith(excluded_dir + '/') or filepath.startswith(normalized + '/'):
                return True

            # Check if excluded directory appears anywhere in the path
            if '/' + normalized + '/' in filepath:
                return True

        return False

    def _is_generated_file(self, content: str) -> bool:
        """Check if file content indicates it's a generated file.

        Args:
            content: File or diff content to check

        Returns:
            True if content appears to be generated
        """
        for marker in self.GENERATED_FILE_MARKERS:
            if marker in content:
                return True
        return False

    def _filter_diff(self, diff_text: str) -> str:
        """Filter out generated files and excluded directories from diff content.

        Args:
            diff_text: Raw diff text

        Returns:
            Filtered diff text
        """
        if not self.excluded_dirs and not self.filter_generated:
            return diff_text

        file_sections = re.split(r'(?=^diff --git)', diff_text, flags=re.MULTILINE)
        filtered_sections = []

        for section in file_sections:
            if not section.strip():
                continue

            # Skip generated files if filtering is enabled
            if self.filter_generated and self._is_generated_file(section):
                logger.debug("Filtering out generated file section")
                continue

            # Extract filename from diff header and check exclusions
            match = re.match(r'^diff --git a/(.*?) b/', section)
            if match:
                filename = match.group(1)
                if self._is_excluded(filename):
                    logger.debug(f"Filtering out excluded file: {filename}")
                    continue

            filtered_sections.append(section)

        return ''.join(filtered_sections)

    def _filter_files(self, files: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Filter out excluded files from file list.

        Args:
            files: List of file dictionaries

        Returns:
            Filtered list of files
        """
        if not self.excluded_dirs and not self.filter_generated:
            return files

        filtered = []
        for f in files:
            filename = f.get('filename', '')

            # Check exclusion
            if self._is_excluded(filename):
                logger.debug(f"Filtering out excluded file: {filename}")
                continue

            # Check if generated (based on patch content)
            if self.filter_generated:
                patch = f.get('patch', '')
                if patch and self._is_generated_file(patch):
                    logger.debug(f"Filtering out generated file: {filename}")
                    continue

            filtered.append(f)

        return filtered

    def get_repository(self, owner: str, repo: str) -> Dict[str, Any]:
        """Get repository information.

        Args:
            owner: Repository owner
            repo: Repository name

        Returns:
            Repository data dictionary
        """
        url = f"{self.base_url}/repos/{owner}/{repo}"
        response = self.session.get(url, timeout=30)

        if response.status_code == 404:
            raise GitHubAPIError(f"Repository not found: {owner}/{repo}")
        response.raise_for_status()

        data = response.json()
        return {
            'id': data['id'],
            'name': data['name'],
            'full_name': data['full_name'],
            'owner': data['owner']['login'],
            'description': data.get('description'),
            'url': data['html_url'],
            'default_branch': data['default_branch'],
            'private': data['private'],
            'language': data.get('language'),
            'stargazers_count': data.get('stargazers_count', 0),
            'forks_count': data.get('forks_count', 0),
        }

    def list_pull_requests(
        self,
        owner: str,
        repo: str,
        state: str = 'open',
        per_page: int = 30,
        include_stats: bool = False
    ) -> List[Dict[str, Any]]:
        """List pull requests for a repository.

        Args:
            owner: Repository owner
            repo: Repository name
            state: PR state ('open', 'closed', 'all')
            per_page: Number of PRs per page (max 100)
            include_stats: If True, fetch detailed stats (additions/deletions/changed_files)
                          for each PR. This makes additional API calls.

        Returns:
            List of PR data dictionaries
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls"
        params = {
            'state': state,
            'per_page': min(per_page, 100),
            'sort': 'updated',
            'direction': 'desc'
        }

        response = self.session.get(url, params=params, timeout=30)
        response.raise_for_status()

        prs = []
        for pr in response.json():
            pr_data = {
                'id': pr['id'],
                'number': pr['number'],
                'title': pr['title'],
                'state': pr['state'],
                'author': pr['user']['login'],
                'created_at': pr['created_at'],
                'updated_at': pr['updated_at'],
                'html_url': pr['html_url'],
                'head_branch': pr['head']['ref'],
                'base_branch': pr['base']['ref'],
                'draft': pr.get('draft', False),
                'additions': pr.get('additions'),
                'deletions': pr.get('deletions'),
                'changed_files': pr.get('changed_files'),
            }

            # If stats requested and not present, fetch from detail endpoint
            if include_stats and pr_data['additions'] is None:
                try:
                    detail = self.get_pull_request(owner, repo, pr['number'])
                    pr_data['additions'] = detail.get('additions', 0)
                    pr_data['deletions'] = detail.get('deletions', 0)
                    pr_data['changed_files'] = detail.get('changed_files', 0)
                except Exception as e:
                    logger.warning(f"Failed to fetch PR details for #{pr['number']}: {e}")

            prs.append(pr_data)

        return prs

    def get_pull_request(self, owner: str, repo: str, pr_number: int) -> Dict[str, Any]:
        """Get detailed pull request information.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: Pull request number

        Returns:
            PR data dictionary
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}"
        response = self.session.get(url, timeout=30)

        if response.status_code == 404:
            raise GitHubAPIError(f"Pull request not found: {owner}/{repo}#{pr_number}")
        response.raise_for_status()

        pr = response.json()
        return {
            'id': pr['id'],
            'number': pr['number'],
            'title': pr['title'],
            'body': pr.get('body', ''),
            'state': pr['state'],
            'merged': pr.get('merged', False),
            'author': pr['user']['login'],
            'created_at': pr['created_at'],
            'updated_at': pr['updated_at'],
            'merged_at': pr.get('merged_at'),
            'html_url': pr['html_url'],
            'head_branch': pr['head']['ref'],
            'head_sha': pr['head']['sha'],
            'base_branch': pr['base']['ref'],
            'base_sha': pr['base']['sha'],
            'additions': pr.get('additions', 0),
            'deletions': pr.get('deletions', 0),
            'changed_files': pr.get('changed_files', 0),
            'commits': pr.get('commits', 0),
            'mergeable': pr.get('mergeable'),
            'draft': pr.get('draft', False),
            # Additional fields for GitHub Actions compatibility
            'head': {
                'ref': pr['head']['ref'],
                'sha': pr['head']['sha'],
                'repo': {
                    'full_name': pr['head']['repo']['full_name'] if pr['head']['repo'] else f"{owner}/{repo}"
                }
            },
            'base': {
                'ref': pr['base']['ref'],
                'sha': pr['base']['sha']
            },
            'user': pr['user']['login'],
        }

    def get_pull_request_files(
        self,
        owner: str,
        repo: str,
        pr_number: int,
        apply_filters: bool = True
    ) -> List[Dict[str, Any]]:
        """Get list of files changed in a pull request.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: Pull request number
            apply_filters: Whether to apply exclusion filters

        Returns:
            List of changed files with their patches
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}/files"
        params = {'per_page': 100}

        all_files = []
        page = 1

        while True:
            params['page'] = page
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()

            files = response.json()
            if not files:
                break

            for f in files:
                all_files.append({
                    'filename': f['filename'],
                    'status': f['status'],  # added, removed, modified, renamed
                    'additions': f['additions'],
                    'deletions': f['deletions'],
                    'changes': f['changes'],
                    'patch': f.get('patch', ''),
                    'previous_filename': f.get('previous_filename'),
                })

            if len(files) < 100:
                break
            page += 1

        # Apply filters if requested
        if apply_filters:
            all_files = self._filter_files(all_files)

        return all_files

    def get_pull_request_diff(
        self,
        owner: str,
        repo: str,
        pr_number: int,
        apply_filters: bool = True
    ) -> str:
        """Get complete PR diff in unified format.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: Pull request number
            apply_filters: Whether to apply exclusion filters

        Returns:
            Complete PR diff as a string in unified diff format
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}"
        headers = dict(self.headers)
        headers['Accept'] = 'application/vnd.github.diff'

        # Use session with retry, but with custom headers for diff format
        max_retries = 3
        response = None
        for attempt in range(max_retries):
            try:
                response = self.session.get(url, headers=headers, timeout=60)
                if response.status_code == 404:
                    raise GitHubAPIError(f"Pull request not found: {owner}/{repo}#{pr_number}")
                response.raise_for_status()
                break
            except (requests.exceptions.SSLError, requests.exceptions.ConnectionError) as e:
                if attempt < max_retries - 1:
                    wait_time = (attempt + 1) * 2
                    logger.warning(f"Network error fetching diff, retrying in {wait_time}s: {e}")
                    time.sleep(wait_time)
                else:
                    raise GitHubAPIError(f"Failed to fetch PR diff after {max_retries} attempts: {e}")

        if response is None:
            raise GitHubAPIError(f"Failed to fetch PR diff: no response received")

        diff_text = response.text

        # Apply filters if requested
        if apply_filters:
            diff_text = self._filter_diff(diff_text)

        return diff_text

    def get_file_content(
        self,
        owner: str,
        repo: str,
        path: str,
        ref: Optional[str] = None
    ) -> Tuple[bool, str, str]:
        """Get content of a file from the repository.

        Args:
            owner: Repository owner
            repo: Repository name
            path: File path in repository
            ref: Git ref (branch, tag, commit SHA). Defaults to default branch.

        Returns:
            Tuple of (success, content, error_message)
        """
        try:
            url = f"{self.base_url}/repos/{owner}/{repo}/contents/{path}"
            params = {}
            if ref:
                params['ref'] = ref

            response = self.session.get(url, params=params, timeout=30)

            if response.status_code == 404:
                return False, "", f"File not found: {path}"

            response.raise_for_status()
            data = response.json()

            # Handle file content
            if data.get('type') == 'file':
                content = base64.b64decode(data['content']).decode('utf-8')
                return True, content, ""
            else:
                return False, "", f"Path is not a file: {path}"

        except Exception as e:
            return False, "", f"Error fetching file: {str(e)}"

    def get_pr_review_data(
        self,
        owner: str,
        repo: str,
        pr_number: int,
        apply_filters: bool = True
    ) -> Dict[str, Any]:
        """Get comprehensive PR data for code review.

        Combines PR info, files, and diff into a single response.
        This method is compatible with both Web app and GitHub Actions usage.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: Pull request number
            apply_filters: Whether to apply exclusion filters

        Returns:
            Dictionary with complete PR review data
        """
        logger.info(f"Fetching review data for {owner}/{repo}#{pr_number}")

        # Get PR details
        pr_info = self.get_pull_request(owner, repo, pr_number)

        # Get files with patches
        files = self.get_pull_request_files(owner, repo, pr_number, apply_filters)

        # Get complete diff
        diff = self.get_pull_request_diff(owner, repo, pr_number, apply_filters)

        return {
            'pr': pr_info,
            'files': files,
            'diff': diff,
            'context': {
                'repo_name': f"{owner}/{repo}",
                'pr_number': pr_number,
                'title': pr_info['title'],
                'description': pr_info.get('body', ''),
                'author': pr_info['author'],
                'base_branch': pr_info['base_branch'],
                'head_branch': pr_info['head_branch'],
            },
            # GitHub Actions compatible fields
            'number': pr_info['number'],
            'title': pr_info['title'],
            'body': pr_info.get('body', ''),
            'user': pr_info['author'],
            'created_at': pr_info['created_at'],
            'updated_at': pr_info['updated_at'],
            'state': pr_info['state'],
            'head': pr_info.get('head', {}),
            'base': pr_info.get('base', {}),
            'additions': pr_info.get('additions', 0),
            'deletions': pr_info.get('deletions', 0),
            'changed_files': pr_info.get('changed_files', 0),
        }

    # Alias methods for GitHub Actions compatibility
    def get_pr_data(self, repo_name: str, pr_number: int) -> Dict[str, Any]:
        """Get PR data (GitHub Actions compatible method).

        Args:
            repo_name: Repository name in format "owner/repo"
            pr_number: Pull request number

        Returns:
            Dictionary containing PR data
        """
        parts = repo_name.split('/')
        if len(parts) != 2:
            raise ValueError(f"Invalid repo_name format: {repo_name}. Expected 'owner/repo'")
        owner, repo = parts
        return self.get_pr_review_data(owner, repo, pr_number)

    def get_pr_diff(self, repo_name: str, pr_number: int) -> str:
        """Get PR diff (GitHub Actions compatible method).

        Args:
            repo_name: Repository name in format "owner/repo"
            pr_number: Pull request number

        Returns:
            Complete PR diff in unified format
        """
        parts = repo_name.split('/')
        if len(parts) != 2:
            raise ValueError(f"Invalid repo_name format: {repo_name}. Expected 'owner/repo'")
        owner, repo = parts
        return self.get_pull_request_diff(owner, repo, pr_number)

    def get_pr_files(self, owner: str, repo: str, pr_number: int) -> List[Dict[str, Any]]:
        """Get list of files changed in a PR.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: PR number

        Returns:
            List of file information dictionaries
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}/files"
        try:
            response = self.session.get(url, timeout=30, params={'per_page': 100})
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            raise GitHubAPIError(f"Failed to get PR files: {e}")

    def create_pr_review(
        self,
        owner: str,
        repo: str,
        pr_number: int,
        body: str,
        event: str = "COMMENT",
        comments: Optional[List[Dict[str, Any]]] = None,
        commit_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create a review on a pull request.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: PR number
            body: The review summary comment
            event: Review event type: APPROVE, REQUEST_CHANGES, or COMMENT
            comments: List of inline review comments
            commit_id: The SHA of the commit to review (optional, uses HEAD if not provided)

        Returns:
            Created review data
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}/reviews"

        # Get commit ID if not provided
        if not commit_id:
            pr_data = self.get_pull_request(owner, repo, pr_number)
            commit_id = pr_data.get('head_sha')

        data = {
            "body": body,
            "event": event,
            "commit_id": commit_id
        }

        if comments:
            data["comments"] = comments

        try:
            response = self.session.post(url, json=data, timeout=30)
            response.raise_for_status()
            logger.info(f"Created PR review on {owner}/{repo}#{pr_number}")
            return response.json()
        except requests.RequestException as e:
            error_detail = ""
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_detail = e.response.json()
                except:
                    error_detail = e.response.text
            raise GitHubAPIError(f"Failed to create PR review: {e}. Detail: {error_detail}")

    def create_pr_comment(
        self,
        owner: str,
        repo: str,
        pr_number: int,
        body: str,
        path: str,
        line: int,
        commit_id: Optional[str] = None,
        side: str = "RIGHT",
        start_line: Optional[int] = None,
        start_side: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create an inline comment on a pull request.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: PR number
            body: Comment body (supports GitHub markdown including suggestion blocks)
            path: File path relative to repo root
            line: Line number to comment on
            commit_id: SHA of commit to comment on
            side: Side of the diff (LEFT or RIGHT)
            start_line: Starting line for multi-line comments
            start_side: Side for start_line

        Returns:
            Created comment data
        """
        url = f"{self.base_url}/repos/{owner}/{repo}/pulls/{pr_number}/comments"

        # Get commit ID if not provided
        if not commit_id:
            pr_data = self.get_pull_request(owner, repo, pr_number)
            commit_id = pr_data.get('head_sha')

        data = {
            "body": body,
            "commit_id": commit_id,
            "path": path,
            "line": line,
            "side": side
        }

        if start_line is not None:
            data["start_line"] = start_line
            data["start_side"] = start_side or side

        try:
            response = self.session.post(url, json=data, timeout=30)
            response.raise_for_status()
            logger.info(f"Created inline comment on {owner}/{repo}#{pr_number} at {path}:{line}")
            return response.json()
        except requests.RequestException as e:
            error_detail = ""
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_detail = e.response.json()
                except:
                    error_detail = e.response.text
            raise GitHubAPIError(f"Failed to create PR comment: {e}. Detail: {error_detail}")

    def format_suggested_change(self, code: str) -> str:
        """Format code as a GitHub suggestion block.

        Args:
            code: The suggested replacement code

        Returns:
            Markdown formatted suggestion block
        """
        return f"```suggestion\n{code}\n```"


def get_github_client(
    token: Optional[str] = None,
    excluded_dirs: Optional[List[str]] = None,
    filter_generated: bool = False
) -> GitHubClient:
    """Convenience function to get GitHub API client.

    Args:
        token: Optional GitHub token (reads from environment if not provided)
        excluded_dirs: Optional list of directories to exclude
        filter_generated: Whether to filter generated files

    Returns:
        Initialized GitHubClient instance
    """
    return GitHubClient(
        token=token,
        excluded_dirs=excluded_dirs,
        filter_generated=filter_generated
    )


# Alias for backward compatibility with github_action_client.py
GitHubActionClient = GitHubClient
